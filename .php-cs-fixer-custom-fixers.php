<?php

declare(strict_types=1);

use PhpCsFixer\AbstractFixer;
use PhpCsFixer\Fixer\ConfigurableFixerInterface;
use PhpCsFixer\FixerConfiguration\FixerConfigurationResolver;
use PhpCsFixer\FixerConfiguration\FixerConfigurationResolverInterface;
use PhpCsFixer\FixerConfiguration\FixerOptionBuilder;
use PhpCsFixer\FixerDefinition\CodeSample;
use PhpCsFixer\FixerDefinition\FixerDefinition;
use PhpCsFixer\FixerDefinition\FixerDefinitionInterface;
use PhpCsFixer\Tokenizer\CT;
use PhpCsFixer\Tokenizer\Token;
use PhpCsFixer\Tokenizer\Tokens;

/**
 * @phpstan-type _AutogeneratedInputConfiguration array{
 *  minimum_parameters?: int,
 * }
 * @phpstan-type _AutogeneratedComputedConfiguration array{
 *  minimum_parameters: int,
 * }
 *
 * @implements ConfigurableFixerInterface<_AutogeneratedInputConfiguration, _AutogeneratedComputedConfiguration>
 *
 * Aligns named parameters in multiline function/method calls.
 */
final class AlignNamedParametersFixer extends AbstractFixer implements ConfigurableFixerInterface
{
    /**
     * @var _AutogeneratedComputedConfiguration
     */
    protected array $configuration = [
        'minimum_parameters' => 2,
    ];

    public function getDefinition(): FixerDefinitionInterface
    {
        return new FixerDefinition(
            'Align named parameters in multiline function/method calls.',
            [
                new CodeSample(
                    '<?php
$obj = new SomeClass(
    short: $value1,
    veryLongParameterName: $value2,
    param: $value3,
);
',
                ),
            ],
        );
    }

    public function getName(): string
    {
        return 'Motoaction/align_named_parameters';
    }

    public function getPriority(): int
    {
        // Run after method_argument_space
        return -30;
    }

    public function isCandidate(Tokens $tokens): bool
    {
        return $tokens->isTokenKindFound('(') && $tokens->isTokenKindFound(CT::T_NAMED_ARGUMENT_NAME);
    }

    public function configure(array $configuration): void
    {
        /** @var array{minimum_parameters?: int} $configuration */
        $resolved = $this->getConfigurationDefinition()->resolve($configuration);
        /** @var array{minimum_parameters: int} $resolved */
        $this->configuration = $resolved;
    }

    public function getConfigurationDefinition(): FixerConfigurationResolverInterface
    {
        return new FixerConfigurationResolver([
            (new FixerOptionBuilder('minimum_parameters', 'Minimum number of parameters to trigger alignment.'))
                ->setAllowedTypes(['int'])
                ->setDefault(2)
                ->getOption(),
        ]);
    }

    protected function applyFix(SplFileInfo $file, Tokens $tokens): void
    {
        // Iterate through all tokens looking for opening parentheses
        for ($index = $tokens->count() - 1; $index >= 0; --$index) {
            if ( ! $tokens[$index]->equals('(')) {
                continue;
            }

            $this->fixNamedParametersAlignment($tokens, $index);
        }
    }

    private function fixNamedParametersAlignment(Tokens $tokens, int $openParenIndex): void
    {
        $closeParenIndex = $tokens->findBlockEnd(Tokens::BLOCK_TYPE_PARENTHESIS_BRACE, $openParenIndex);

        // Find named parameters and check count first
        $namedParams = $this->findNamedParameters($tokens, $openParenIndex, $closeParenIndex);
        $paramCount = count($namedParams);

        // Normalize single-parameter calls (remove excessive spaces)
        if ($paramCount === 1) {
            $this->normalizeSingleParameterSpacing($tokens, $namedParams[0]);
            return;
        }

        // Only process multiline calls with 2+ parameters
        if ($paramCount < $this->configuration['minimum_parameters']) {
            return;
        }

        if ( ! $this->isMultilineCall($tokens, $openParenIndex, $closeParenIndex)) {
            return;
        }

        // Calculate the maximum parameter name length and apply alignment
        $maxLength = $this->calculateMaxParameterLength($namedParams);
        $this->alignParameters($tokens, $namedParams, $maxLength);
    }

    /**
     * @return array<int, array{name: string, colonIndex: int, nameIndex: int}>
     */
    private function findNamedParameters(Tokens $tokens, int $start, int $end): array
    {
        $namedParams = [];
        $depth = 0; // Track nesting depth to ignore nested function calls

        for ($i = $start + 1; $i < $end; ++$i) {
            // Track nesting depth - ignore parameters inside nested function calls
            if ($tokens[$i]->equals('(')) {
                $depth++;
                continue;
            }

            if ($tokens[$i]->equals(')')) {
                $depth--;
                continue;
            }

            // Only process named parameters at depth 0 (direct parameters of this call)
            if ($depth === 0 && $tokens[$i]->isGivenKind([CT::T_NAMED_ARGUMENT_NAME])) {
                $nextMeaningfulIndex = $tokens->getNextMeaningfulToken($i);

                if ($nextMeaningfulIndex && $tokens[$nextMeaningfulIndex]->isGivenKind([CT::T_NAMED_ARGUMENT_COLON])) {
                    $namedParams[] = [
                        'name'       => $tokens[$i]->getContent(),
                        'colonIndex' => $nextMeaningfulIndex,
                        'nameIndex'  => $i,
                    ];
                }
            }
        }

        return $namedParams;
    }

    private function isMultilineCall(Tokens $tokens, int $start, int $end): bool
    {
        for ($i = $start + 1; $i < $end; ++$i) {
            if ($tokens[$i]->isGivenKind(T_WHITESPACE)) {
                $content = $tokens[$i]->getContent();
                if (str_contains($content, "\n")) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * @param array<int, array{name: string, colonIndex: int, nameIndex: int}> $namedParams
     */
    private function calculateMaxParameterLength(array $namedParams): int
    {
        $maxLength = 0;

        foreach ($namedParams as $param) {
            $maxLength = max($maxLength, mb_strlen($param['name']));
        }

        return $maxLength;
    }

    /**
     * @param array<int, array{name: string, colonIndex: int, nameIndex: int}> $namedParams
     */
    private function alignParameters(Tokens $tokens, array $namedParams, int $maxLength): void
    {
        // Process in reverse order to maintain token indices
        foreach (array_reverse($namedParams) as $param) {
            $currentLength = mb_strlen($param['name']);
            $spacesNeeded  = $maxLength - $currentLength;

            $nameIndex  = $param['nameIndex'];
            $colonIndex = $param['colonIndex'];

            // Calculate spaces needed for alignment (always at least 1 space before colon)
            $spacesToAdd = $spacesNeeded + 1;

            // Check if there's already whitespace between name and colon
            if ($nameIndex + 1 < $colonIndex) {
                // There's whitespace, replace it with aligned spaces
                $tokens[$nameIndex + 1] = new Token([T_WHITESPACE, str_repeat(' ', $spacesToAdd)]);
            } else {
                // No whitespace, insert aligned spaces
                $tokens->insertAt($colonIndex, new Token([T_WHITESPACE, str_repeat(' ', $spacesToAdd)]));
            }
        }
    }

    /**
     * Normalizes spacing for single-parameter calls by removing all spaces before colon.
     *
     * @param array{name: string, colonIndex: int, nameIndex: int} $param
     */
    private function normalizeSingleParameterSpacing(Tokens $tokens, array $param): void
    {
        $nameIndex  = $param['nameIndex'];
        $colonIndex = $param['colonIndex'];

        // Remove all whitespace between name and colon (no space before colon for single parameters)
        if ($nameIndex + 1 < $colonIndex) {
            for ($i = $colonIndex - 1; $i > $nameIndex; $i--) {
                if ($tokens[$i]->isGivenKind(T_WHITESPACE)) {
                    $tokens->clearAt($i);
                }
            }
        }
    }
}

// Add more custom fixers below as needed...

/**
 * Returns an array of all custom fixers defined in this file.
 *
 * @return array<AbstractFixer>
 */
function getCustomFixers(): array
{
    return [
        new AlignNamedParametersFixer(),
        // Add new fixers here as you create them
    ];
}
